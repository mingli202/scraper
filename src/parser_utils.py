from collections import OrderedDict
import itertools
from pathlib import Path
import re

import pdfplumber
from pdfplumber.page import Page
from models import ColumnsXs, Word


class ParserUtils:
    @staticmethod
    def compute_sorted_lines(pdf_path: Path) -> OrderedDict[int, list[Word]]:
        lines: OrderedDict[int, list[Word]] = OrderedDict()

        with pdfplumber.open(pdf_path) as pdf:
            sorted_words = itertools.chain.from_iterable(
                ParserUtils.__get_sorted_words(i, page)
                for i, page in enumerate(pdf.pages)
            )

            y = -1
            line: list[Word] = []
            for word in sorted_words:
                if word.doctop != y:
                    if y != -1:
                        lines.update({y: line})
                        line = []
                    y = word.doctop

                line.append(word)

            lines.update({y: line})

        return lines

    @staticmethod
    def __get_sorted_words(page_number: int, page: Page) -> list[Word]:
        words = page.extract_words(x_tolerance=1.789)

        sorted_words = sorted(
            (
                Word(
                    text=ParserUtils.sanitize_string(word["text"]),
                    x0=round(word["x0"]),
                    doctop=round(word["doctop"]),
                    top=round(word["top"]),
                    page_number=page_number,
                )
                for word in words
            ),
            key=lambda w: (w.top, w.x0),
        )

        return [Word.model_validate(w, by_alias=True) for w in sorted_words]

    @staticmethod
    def sanitize_string(s: str):
        s = s.replace("\u00e9", "e")  #  removes é
        s = s.replace("\u00c9", "E")  #  removes É
        s = s.replace("\u00e8", "e")  #  removes è
        s = s.replace("\u00e2", "a")  #  removes â
        s = s.replace("\u00e7", "c")  #  removes ç
        s = s.replace("\u00e0", "a")  #  removes à
        s = s.replace("\u0000", "")  #  removes null character
        s = re.sub(
            r"\(cid:\d+\)", "", s
        )  #  removes null character generated by pdfplumber

        return s

    @staticmethod
    def compute_columns_x(
        sorted_lines_dict: OrderedDict[int, list[Word]],
    ) -> ColumnsXs:
        # using the first class section to get all the columns
        columns_x_dict: dict[str, list[int]] = {}
        sorted_lines = list(sorted_lines_dict.values())
        i = 0
        while i < len(sorted_lines):
            line = sorted_lines[i]

            if line[0].text == "SECTION":
                break

            i += 1

        for word in sorted_lines[i]:
            text: str = word.text
            columns_x_dict.setdefault(text, []).append(word.x0)

        i += 1

        section_first_line = sorted_lines[i]

        assert re.match(r"\d{4}-\d{4}", section_first_line[-1].text)
        time_column = section_first_line[-1].x0

        assert re.match(r"[TMWRF]{1,5}", section_first_line[-2].text)
        day_column = section_first_line[-2].x0

        columns_x = ColumnsXs(
            section=columns_x_dict["SECTION"].pop(),
            disc=columns_x_dict["DISC"].pop(),
            day=day_column,
            time=time_column,
            course_number=columns_x_dict["COURSE"][0],
            course_title=columns_x_dict["COURSE"][1],
        )

        return columns_x
